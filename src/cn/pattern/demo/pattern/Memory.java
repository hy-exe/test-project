package cn.pattern.demo.pattern;

import java.util.Vector;

/**
 * java的指针： 栈中的变量指向堆中的对象。
 * java内存泄露： 内存对象在不需要时，仍保留着这块内存和它的引用。严格上讲是指：一块内存不可达了。
 * 
 * java中有六个地方可以存放数据。
 * 1. 寄存器     执行最快的区域    有编译器根据需求进行分配   无法直接控制。
 * 2. 堆栈        位于RAM 通过 “堆栈指针”，向下移动则分配新的内存，向上则释放内存。自动分配内存，后进先出。
 * 3. 堆            通用的内存池（RAM），存放所以java对象和数组，比堆栈的好处是编译器不需要知道分配多少区域和存活多长时间。
 * 			      当创建了一个对象后，还可以在栈中定义一个特殊的变量，变量取值等于对象在堆中的首地址，该变量则为对象的引用变量。
 * 4. 静态存储 “静态”指固定位置，程序运行是一直存在的数据，可以使用static来标识一个对象的特定元素是静态的，java对象本身不会存放在该区域。
 * 5. 常量存储 
 * 6. 非RAM存储
 */

/**
 *  内存泄露
 *  本例中，在栈中存在两个引用变量V 和 O，当引用变量o置空后，由于在v引用指向的内存空间存在指向Object对象的引用，
 *  因此Object对象虽然没有什么用了，但是GC并不会释放该内存。
 *  
 *  容易存在内存泄露的情况：
 *  1、静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，
 *  	所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。
 *	2、内部类和外部类的引用容易出现内存泄露的问题
 *	3、监听器的使用，java中往往会使用到监听器，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。
 *	4、大量临时变量的使用，没有及时将对象设置为null也可能导致内存的泄露
 *	5、数据库的连接没有关闭情况，包括连接池方法连接数据库，如果没有关闭ResultSet等也都可能出现内存泄露的问题。
 *
 */
@SuppressWarnings("all")
public class Memory{
	
	public static void main(String args[]){
		Vector v = new Vector();
		for(int i=1;i<10;i++){
			Object o = new Object();
			v.add(o);
			o = null;
		}
	}
}
